The basic reason why `Applicative []` has the generate-all-possible-combinations behaviour, rather than any kind of zippy behaviour, is that `Applicative` is a superclass of `Monad` and is intended to behave in accordance with the `Monad` instance when one exists. `Monad []` treats lists as failure-and-prioritized-choice, so the `Applicative []` instance does, too. People often refactor monadic code using the applicative interface to reduce the number of intermediate names needed for values, and to increase opportunities for parallelism. It would be pretty scary if that caused a significant shift in the functional semantics.

That aside, the truth is, you're spoilt for choice for `Applicative []` instances, and even more so if you consider empty/nonempty and finite/coinductive/infinite variations. Why is that?

Well, as I mentioned in [this answer](https://stackoverflow.com/a/50717675/828361), every `Applicative f` begins its life as a `Monoid (f ())`, combining the *shapes* of the data, before we start to worry about the *values*. Lists are a case in point.

`[()]` is basically the type of numbers. Numbers are monoids in lots of ways.

Taking `Applicative []` from `Monad []` amounts to choosing the monoid generated by `1` and `*`.

Meanwhile, `Applicative ZipList` exploits Haskell's coinductive conflation and amounts to choosing the monoid generated by infinity and minimum.

The question proposes an instance which is not lawful, but is close to one that is. You'll notice `<*>` isn't defined for an empty list of functions, but for nonempty lists of functions, it pads out to match the list of arguments. Asymmetrically, it truncates when the arguments run out. Something's not quite right.

Two candidate fixes follow.

One is to truncate on empty on both sides, and then you must take `pure = repeat` and you have `ZipList`.

The other is to rule out empty lists and pad on both sides. Then you get the `Applicative` generated from the `Monoid` on *positive* numbers generated by 1 and *maximum*. So it's not `ZipList` at all. That's the thing I called `PadMe` in [this answer](https://stackoverflow.com/a/21350096/828361). The reason you need to rule out 0 is that for every position in the output of `<*>`, you need to point to the position in both inputs where the function and its arguments (respectively) come from. You can't pad if you have nothing to pad with.

It's a fun game. Pick a `Monoid` on numbers and see if you can grow it into an `Applicative` for lists!
